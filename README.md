## Android

# Recovery Mode

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/7dc34306-15a4-492f-ac47-eb12e6397f7b)

> Los distintos fabricantes suelen personalizar este modo de recuperación, de modo que las opciones disponibles pueden ser diferentes dependiendo de la marca a la que pertenezca cada móvil. Pero los elementos que todos suelen mantener son los que ya te hemos contado, los de borrar la caché del sistema o eliminar la partición de datos, dos técnicas que pueden solucionar algunos problemas con el móvil.

> Esto quiere decir que existe la posibilidad de poder instalar modos de recuperación mejorados con más opciones de las que trae la versión de serie. Dos buenos ejemplos son CWM (ClockWorkMod) o TWRP, que incluyen añadidos como instalar otras versiones de Android, borrar particiones o usar una Interfaz táctil en lugar de los botones físicos.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/0f2bc189-e49d-4110-bc71-02eb2f5c5c1c)


El modo de recuperación (recovery mode) es un entorno de arranque especial en los dispositivos Android que proporciona una serie de opciones de recuperación y mantenimiento. A continuación, se presentan algunos términos técnicos clave relacionados con el modo de recuperación:

> Recovery Mode: Es el modo de recuperación propiamente dicho. Permite acceder a un sistema operativo de recuperación que puede utilizarse para realizar tareas de mantenimiento y solucionar problemas en el dispositivo.

> Bootloader: Es un programa que se ejecuta antes del sistema operativo principal y tiene la capacidad de cargar diferentes sistemas operativos o entornos, incluido el modo de recuperación. El bootloader también controla el desbloqueo del gestor de arranque (bootloader unlocking).

> Factory Reset: Es una opción disponible en el modo de recuperación que permite restablecer el dispositivo a la configuración de fábrica. Esto borra todos los datos y aplicaciones almacenados en el dispositivo.

> Wipe Cache Partition: Es una opción que permite borrar la partición de caché del dispositivo. La caché es una área de almacenamiento temporal utilizada por el sistema operativo y las aplicaciones, y borrarla puede solucionar problemas de rendimiento y estabilidad.

>  ADB (Android Debug Bridge): Es una herramienta de línea de comandos utilizada para comunicarse con un dispositivo Android desde un ordenador. En el modo de recuperación.


## Arquitectura

Android es un sistema operativo basado en el kernel de Linux. Está diseñado con una arquitectura de capas que consta de varios componentes clave (no estan puestos como capa OSI) son componentes que se tiene que saber que existen y que son fin.

### Aplicaciones

Las aplicaciones de Android se desarrollan utilizando el Android Software Development Kit (SDK) y se ejecutan en el entorno de tiempo de ejecución de Android (Android Runtime, ART).
El lenguaje de programación principal para el desarrollo de aplicaciones en Android es Java o Kotlin.

### Componentes de la aplicación

- Activity:

Representa una pantalla o una parte de la interfaz de usuario de la aplicación.

- Service:

Es un componente que se ejecuta en segundo plano para realizar tareas de larga duración sin una interfaz de usuario visible.

- Content Provider
 
Proporciona una interfaz para acceder y compartir datos entre aplicaciones.

- Broadcast Receiver

Permite a las aplicaciones recibir y responder a eventos del sistema o personalizados.

-Manifest File

Es un archivo XML que describe la estructura y los componentes de la aplicación, así como los permisos necesarios para acceder a determinadas funciones del sistema.

- Intents

Son mensajes asíncronos utilizados para comunicarse entre diferentes componentes de la aplicación o entre diferentes aplicaciones.

- API (Application Programming Interface)

Es un conjunto de interfaces y funciones que permiten a los desarrolladores acceder a las funciones y servicios del sistema operativo Android.

- Gradle

Es una herramienta de construcción utilizada para compilar y administrar dependencias en proyectos de Android. Se utiliza para construir el APK (Android Package) final de la aplicación.

- Emulador de Android

Es una herramienta que permite ejecutar y probar aplicaciones de Android en un entorno virtual en lugar de un dispositivo físico.

# Ciber Seguridad Android conceptos 

### Arquitectura de seguridad de aplicaciones móviles:

- Autenticación:

Es el proceso de verificar la identidad de un usuario o dispositivo antes de permitir el acceso a la aplicación.

- Autorización:

Consiste en otorgar los permisos adecuados a los usuarios o dispositivos para acceder a determinadas funciones o datos de la aplicación.
Encriptación: Es el proceso de convertir datos en un formato ilegible para proteger su confidencialidad. Los algoritmos de encriptación se utilizan para cifrar y descifrar los datos.

- Firma de aplicaciones (App Signing):

Es el proceso de firmar digitalmente una aplicación móvil para verificar su autenticidad e integridad.

- Almacenamiento seguro (Secure Storage): 

Es el uso de técnicas de encriptación y protección de datos para almacenar información sensible de manera segura en el dispositivo.

- Amenazas de seguridad en aplicaciones móviles:

>Man-in-the-Middle (MITM) Attack: Es un ataque en el que un tercero intercepta y modifica las comunicaciones entre la aplicación móvil y el servidor, lo que permite la manipulación de datos o la obtención de información confidencial. 

> Inyección de código (Code Injection): Es un ataque en el que se inserta código malicioso en la aplicación para ejecutar comandos no autorizados en el sistema o para obtener acceso no autorizado a datos sensibles.

> Vulnerabilidades de seguridad conocidas (Known Security Vulnerabilities): Son debilidades o fallos de seguridad previamente identificados en el código de la aplicación o en las bibliotecas utilizadas, que pueden ser explotados por los atacantes.

> Malware: Es software malicioso diseñado para dañar o comprometer la seguridad de un dispositivo o una aplicación móvil.

## El SAST Y DAST

Pruebas de seguridad de aplicaciones móviles:

Análisis de código estático (Static Code Analysis): Es el proceso de examinar el código fuente de una aplicación en busca de posibles vulnerabilidades o debilidades de seguridad.

Análisis de código dinámico (Dynamic Code Analysis): Implica ejecutar la aplicación en un entorno controlado para identificar posibles vulnerabilidades o comportamientos inseguros mientras se está ejecutando.

Pruebas de penetración (Penetration Testing): Consiste en realizar pruebas controladas para identificar vulnerabilidades en la aplicación móvil y evaluar la resistencia de la misma ante ataques.


# Android API Level

En Android se refiere a la versión de la interfaz de programación de aplicaciones (API) que está disponible en un dispositivo Android. Cada versión de Android tiene asignado un número de nivel de API específico.

> En el caso de "API level 29 or later" significa que se requiere la versión de API 29 o superior para utilizar ciertas características o funcionalidades de una aplicación. Esto implica que la aplicación está diseñada para funcionar correctamente en dispositivos con Android 10 (versión de API 29) y versiones posteriores.

> La API level determina las capacidades y las características disponibles para los desarrolladores al crear aplicaciones. A medida que se lanzan nuevas versiones de Android, se introducen mejoras y nuevas API que permiten a los desarrolladores aprovechar las últimas funcionalidades del sistema operativo y brindar una mejor experiencia a los usuarios.

> Es importante tener en cuenta el nivel de API al desarrollar o utilizar aplicaciones, ya que algunas funciones pueden no ser compatibles con versiones anteriores de Android. Por lo tanto, si tu dispositivo tiene una versión de API inferior a 29, es posible que no puedas utilizar ciertas características de una aplicación que requiera ese nivel de API.


Aqui puedes ver las api levels:

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/58414bf3-d867-484a-b69e-551588cee779)


> https://github.com/AndroidSDKSources/android-sdk-sources-list

> https://apilevels.com/

# Android Virtual Machine

En el contexto de Android, la máquina virtual es un componente clave del sistema operativo que se encarga de ejecutar las aplicaciones. Android utiliza una máquina virtual de Java llamada ***"Dalvik Virtual Machine" (DVM)*** en versiones anteriores, y a partir de Android 5.0, se introdujo la ***"Android Runtime" (ART)*** como la nueva máquina virtual predeterminada.

Aquí hay algunas cosas importantes que debes saber sobre la máquina virtual en Android y su relevancia para la ciberseguridad:

1. Ejecución de aplicaciones: La máquina virtual de Android es responsable de ejecutar las aplicaciones en un entorno aislado. Cada aplicación se ejecuta en su propio proceso y espacio de memoria, lo que ayuda a prevenir que una aplicación afecte negativamente a otras o al sistema operativo.

2. Entorno de sandboxing: El entorno de la máquina virtual de Android, junto con las medidas de seguridad adicionales, como los permisos de aplicación y el modelo de seguridad basado en sandboxing, contribuye a la seguridad general del sistema. Esto reduce la posibilidad de que una aplicación maliciosa cause daños o acceda a datos sensibles.

3. Compilación anticipada (Ahead-of-Time Compilation): Con la introducción de ART, Android cambió de la compilación en tiempo de ejecución (Just-in-Time Compilation) a la compilación anticipada (Ahead-of-Time Compilation). Esto implica que las aplicaciones se compilan antes de su instalación, lo que mejora el rendimiento y, en cierta medida, dificulta la realización de ataques basados en la manipulación del código durante la ejecución.

4. Análisis y seguridad de aplicaciones: En el ámbito de la ciberseguridad, es fundamental analizar y evaluar las aplicaciones de Android en busca de posibles vulnerabilidades, malware o comportamientos sospechosos. Esto se puede hacer mediante técnicas como el análisis estático y dinámico de aplicaciones, donde se examinan el código, los permisos, las solicitudes de acceso y el comportamiento en tiempo de ejecución de la aplicación.

Es importante comprender los aspectos relacionados con la máquina virtual en Android, ya que están estrechamente relacionados con la seguridad de las aplicaciones y del sistema en general. Los desarrolladores y profesionales de la ciberseguridad deben estar al tanto de las mejores prácticas de seguridad y las medidas de protección necesarias para mitigar riesgos y proteger los dispositivos Android.

# HTB Pinned

## Protocolo TLS

> TLS (Transport Layer Security) es un protocolo de seguridad de red que proporciona comunicaciones seguras a través de Internet. Es la evolución del protocolo SSL (Secure Sockets Layer) y se utiliza para establecer conexiones cifradas y autenticadas entre un cliente y un servidor.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/da6b8204-fc7b-488d-8d63-9bcc532a1cf3)

> El protocolo TLS se implementa en la capa de transporte del modelo de referencia OSI, asegurando la confidencialidad, integridad y autenticidad de los datos transmitidos. Proporciona una capa de seguridad adicional para protocolos como HTTP, SMTP, FTP y otros, permitiendo que la información sensible viaje de forma segura por la red.

## Caracteristicas

1. Cifrado: TLS utiliza algoritmos de cifrado para proteger los datos durante la transmisión. Esto garantiza que solo el cliente y el servidor puedan entender la información intercambiada, evitando que terceros puedan interceptar y comprender los datos transmitidos.

2. Autenticación: TLS utiliza certificados digitales para verificar la identidad de los participantes en la comunicación. Estos certificados son emitidos por autoridades de certificación confiables y permiten que el cliente y el servidor se autentiquen mutuamente, asegurando que están interactuando con la entidad esperada.

3. Integridad: TLS utiliza funciones de hash para verificar la integridad de los datos transmitidos. Esto significa que cualquier modificación no autorizada en los datos durante la transmisión será detectada, evitando que los datos se alteren en el camino.

4. Negociación de parámetros de seguridad: Antes de establecer una conexión segura, el cliente y el servidor negocian los parámetros de seguridad que utilizarán durante la comunicación. Esto incluye el algoritmo de cifrado, la clave de cifrado y otros aspectos relacionados con la seguridad de la conexión.


## Certificado TLS ( certificados digitales)

Ayudan a verificar la autenticidad de los servidores. Tambien se podria decir que son archivos digitales que pueden certificar el ownership (propiedad) de una clave publica. Son emitidos (issued) por una entidad certificadora CA que es la que los firma. Y esto certifica que ellso verificaron que pertencen a los propietarios del dominio.

> certificando que han verificado que pertenece a los titulares del nombre de dominio objeto del certificado


> Un certificado TLS (Transport Layer Security) es un archivo digital utilizado para establecer conexiones seguras y cifradas en Internet. TLS es un protocolo de seguridad que se utiliza para proteger la comunicación entre un cliente y un servidor, garantizando la confidencialidad, integridad y autenticidad de los datos transmitidos.

> El certificado TLS contiene información sobre la identidad de una entidad en línea, ya sea un sitio web, un servicio en línea u otra entidad. Está firmado por una autoridad de certificación confiable y se utiliza para demostrar la autenticidad del servidor al cliente.

Un certificado TLS incluye los siguientes elementos clave:

1. Información de la entidad: El certificado contiene información sobre la entidad a la que se emite, como el nombre del dominio del sitio web o la dirección IP del servidor.

2. Clave pública: El certificado incluye una clave pública que se utiliza para establecer una conexión segura. Esta clave se utiliza para cifrar los datos transmitidos desde el cliente al servidor.

3. Firma digital: El certificado está firmado digitalmente por una autoridad de certificación confiable. La firma digital garantiza que el certificado no haya sido alterado y que proviene de una entidad legítima.


## Funcionamiento 

Cuando un cliente (como un navegador web) establece una conexión con un servidor protegido con TLS, el servidor presenta su certificado TLS al cliente. El cliente verifica la autenticidad del certificado mediante la comprobación de la firma digital y la confianza en la autoridad de certificación que lo emitió. Si el certificado es válido, el cliente y el servidor pueden establecer una conexión segura y cifrada utilizando la clave pública del certificado.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/85b7972e-922b-47d9-a850-96a69dae0ab7)

1. El usuario o cliente contacta un sitio web seguro ( mira el ejemplo de arriba ). El servidor (htb) manda su ***certificado TLS + clave publica*** con el cliente.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/cfe7c25d-e376-4074-8827-0447c1481e48)

2. El cliente tiene que verificar si puede confiar en el certificado ( Do I trust it?). Si si decide que puede confiar en el certificado envia de regreso una ***clave simetrica de sesion*** (encryptada con la clave publica que le envio junto con el certificado TLS).


3. El servidor desencrypta ( con la clave privada ) el sesion key y manda un ***ACK + secret_key***

4. Ahpra las dos partes se pueden comunicar por un canal seguro.



## El paso 2 ¿ Como verifica si puede o no confiar en el certificado?

Empecemos por entender que los navegadores tienen una lista de trusted CA certificates. Por ejemplo en Firefox

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/64739c42-b569-4232-8ab1-930270ba1d6b)

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/c7d88765-d11b-4a72-9bc0-baf3ca7a1f05)

Entonces cuando el servidor le da un certificado este checa la cadena que todos esten trusted( osea lo que entiendo es que si se encuentren en la lista de certificate authority). Si si estan y esta todo ok se puede continuar con la conexion encriptada de lo contrario se cierra.

# Android CA certificates

Entonces en este challenge necesitamos hacer un MITM para poder esto y desencriptar el trafico entre nuestra app y el server. Y para lograrlo necesitamos poner el certificado de una herramienta proxy como burpsuite para desencriptar el trafico. Pero al parecer apartir de Android 8 (API 24) y para arriba se hizo mas dificil este proceso. *** Android tiene 3 Certificate store***:

## System (/system/etc/security/cacerts/ Y se necesitan permisos root para modificar o agregar a esta ceprta ) 

> Esta carpeta guardas certidicados CA y es el que checan las apps por default.

Cuando un dispositivo Android establece una conexión segura con un servidor, el sistema operativo verifica si el certificado del servidor está firmado por una autoridad de certificación confiable. Para ello, consulta la colección de certificados almacenados en "/system/etc/security/cacerts/" y compara la firma del certificado del servidor con los certificados allí presentes. Si hay una coincidencia, el certificado del servidor se considera válido y se establece la conexión segura.

Es importante destacar que los archivos ubicados en esta ruta están protegidos y requieren permisos de administrador (root) para acceder y modificar. Esto se hace para garantizar la integridad y seguridad del sistema.

## Installed by the user device (/data/misc/user/0/cacerts-added/) TRUSTED BY DEFAULT BEFORE ANDROID 7

Son donde se guardan los certificados installados por el usuario. Pero entonces ***despues de Android 7. Tiene que optar específicamente por confiar en ellos.***

## Certificate Pinning (App itself osea lo guada la app que lo va a usar)

Cada aplicacion puede incluir sus propios certificados renunciando a confiar en cualquier otro instalado. ( tambien los que el systema este guardando). 

Entonces para concluir no existe un metodo como tal para que hagamos que confie en un certificado porque depende de muchas cosas osea hay que ver si tenemo provilegios root, si es una version de android mayor a 7, que tipo de dispositivo, app configurations etc...



![image](https://github.com/gecr07/Android-Pentest/assets/63270579/1e9fb435-c165-4434-b63d-1d13c95744b3)


## APKTOOL

Una herramienta para la ingeniería inversa de aplicaciones de Android binarias, cerradas y de terceros. Puede decodificar recursos a su forma casi original y reconstruirlos después de hacer algunas modificaciones; hace posible depurar código smali paso a paso. También facilita el trabajo con una aplicación debido a la estructura de archivos similar a un proyecto y la automatización de algunas tareas repetitivas como la creación de apk.

```
sudo java -jar apktool_2.9.3.jar d Termux_0.118.0_Apkpure.apk
```


Se genera una carpeta que tiene un proyecto practicamente de la app. Es intersante ver el archivo manifest para ver que requerimientos minimos tiene un app.

## Genymotion

Es un emulador de android y pues instalalo en windows para evitar problemas fin. Para encontrar el puero y la IP (porque no hay otro camino esta cpmplicado no deja descargar nada) vete a la misma configuracion de el emulador

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/52996f9e-49b5-43e5-bcc8-b09567e77122)

### ADB 

Primero para poder usar adb primero tienes que conectarte.

```
adb connect 192.168.56.101:5555

adb device

## Permitir instalar apps de terceros

> https://stackoverflow.com/questions/15014519/apk-installation-failed-install-failed-verification-failure

adb shell settings put global package_verifier_enable 0

## Para acceder a la shell

adb shell

### Para ver los logs del sistema
adb logcat

## Para subir un archivo

adb push path_in_pc  path_to_file_device

## Para descargar archivo

adb pull path_to_file_device path_in_pc

```
Entonces es esta opcion en opciones de desarrolador.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/cac1e866-028b-4e9a-9598-6cb572818dfd)

## Reversing

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/fc755fcc-3bd8-4491-b24e-53a0b42bc2c0)


Los archivos apk son un tipo de archivo zip. Aunque desocmprimas el apk se necesita usar ***APKtool*** para poder ver dentro de los archivos incluso deja volver a rebuilding.

### APKtool

> ![image](https://github.com/gecr07/Android-Pentest/assets/63270579/3bf4e579-e91a-4b81-8a5c-bd7a9b67c40d)

Esta herramienta permite descompilar la apk crea una carpeta con todo lo que tiene el apk. El codigo que genera se le llama SMALi y no es presisamente el de java pero se puede leer

### DEX2JAR d2j-dex2jar

Pues una vez que con apktool descompilas todo el codigo de java queda en .dex por eso es que necesitamos esto para pasar de dex a jar y finalmente poder leerlo con jd-gui. No espera al parecer cuando haces unzip es cuando ves el .dex de la otra manera no.

```
d2j-dex2jar archivo.dex
```





# Extencion .java y archivos a ejecutar .class

Los que se compilan son los .java y los que se ejecutan son los .class y se pueden. Recuerda para poder desarrollar hay que descargar el jdk y el JRE solo sirve para correr cosas.

## SAST MobSF

Para poder realizar analisis estatico usa esta herramienta

> https://github.com/MobSF/Mobile-Security-Framework-MobSF


## Programacion Android Java y Kotlin

Para crear  un proeycto con java tienes que elegir la opcion siguiente:

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/0a1eb7dd-0105-4cc5-bf5e-053764fc36d2)

Porque si eliges la otra automaticamente te va a poner kotlin y y aparece asi:

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/b5ed05b3-76fa-46a4-be24-1b6f7a7c925d)

El grade recuerda sirve para compilar el proyecto en donde va a estar nuestro codigo es en:

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/82f24a86-ece9-4eb6-ba3c-eb4c25f2d24c)

Puedes crear maquinas virtuales (de celulares) el boton es este el del celular. (esta a un lado de la lupa)


![image](https://github.com/gecr07/Android-Pentest/assets/63270579/53f8077c-8933-45b1-a05f-ca1c99f31232)


Para poder hacer cambios en la app mira esta barra.


![image](https://github.com/gecr07/Android-Pentest/assets/63270579/8ba20149-211f-4ece-b2e3-14cd9d4125cd)

## Text View 

Existen muchos elemento dentro de android este por ejemplo es como un label y permite ingresar texto ahora tiene atributos que se pueden modificar el relleno, el margen tamaño de letra. Pero el mas importante en mi punto de vista es el ID porque es el nombre con el cual vamos poder modificarlo desde el codigo.

## Toast

Otro elemento que es muy util se llama toast y es el cirulo o mas bien ovalo que aparece unos segundos y desaparece. 

## ImageText

Elemento que permite mostrar imagenes solo con letras minusculas en el nombre(si no no deja) Las imagenes la copie y pegue en la carpeta(dentro del IDE) de res -> drawable entonces cuando agregar este elemento permite seleccionar que imagen mostrar.


## Codigo

Como se esta programando en Java el codigo va en el MainActivity.java

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/e23defb6-79ea-418a-9d4e-3769c5d88a81)

# Kotlin

Para usar este lenguaje que es como un java recortado primer instalamos el jdk despues instalamos un IDE en este caso usamos IntelliJ vamos a nuevo proyecto y escojemos Kotlin despues vamos a donde esta nuestro paquete y agregamos un archivo de Kotlin kt y ahi ponemos el codigo el siguiente es un framento de un hola mundo.

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/ebc54d45-b253-4eea-b7ff-de2efb9a6a30)

## Tipos de datos

A diferencial de Java todos los tipos son objetos osea que vamos a poder usar caracteristicas o atributos.

> https://kotlinlang.org/docs/basic-types.html

Por ejemplo para definir la edad 

```kotlin
fun main (args: Array<String>)
{
println("Hola mundo")

var edad =28
println(edad)

// para poner una definicios de tipo

var edad:Int = 29

// Para constantes y se puede definir el tipo igual

val nombre = "Juan"
val apellido:String = "Perez"
# Se puede usar interpolacion o expancion creo se le llama

println("El nombre es $nombre y el apellido es: $apellido")  
}

```

## Ingresar datos de usuario

Para ingresar datos es un poco diferente a Java

``` java
fun main (args: Array<String>)
{

println("Dame tu nombre")
var nombre = readLine()
print("El nombre es: $nombre")

    println(" Dame un texto")

    var nombre = readLine()

    println("El nombre es $nombre")

    var eLista= listOf("Juan", "Pedro", "Luisa")

    println("La lista tiene ${eLista.size} elementos")

    println("La lista: $eLista")

var eList2 = mutableListOf("Juan","Karla","Arturo","Laura")
eList2.add("Masapan")

println(eList2.size)
println(eList2[0])
println(eList2)


for (elemento in eList2){
    println(elemento)
}


}
```

## Loops

Se parece mucho a lo de Java

## Funciones 

La funcion main que se define es parecida a la clase que genera java y se pueden crear mas funciones dentro

```
fun main (args: Array<String>)
{

    fun saludar(){
        println("Saludos desde mi nueva funcion ")
    }


    var eList2 = mutableListOf("Juan","Karla","Arturo","Laura")
    eList2.add("Masapan")

    println(eList2.size)
    println(eList2[0])
    println(eList2)


    for (elemento in eList2){
        println(elemento)
    }


    // Maps

   // var traduccion = mapOf("Hola" to "Hello","adios" to "goodbye")

    // para modificar el mapa usa

    var traduccion = mutableMapOf("Hola" to "Hello","adios" to "goodbye")

    traduccion["adios"] = "BYE MASA"

    println(traduccion["adios"])

    saludar()

}
```

## Adroid y kotlin

Crear un proyecto nuevo y elige la actividad con el simbolo de kotlin

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/8985e64d-a69d-460a-a480-097961c13da8)


Y en el video marca que use la misma configuracion y solo que vea que tiene la opcion de Kotlin

![image](https://github.com/gecr07/Android-Pentest/assets/63270579/6b7e05fc-08c4-4d0f-9147-a119be670f4e)




# Bibliografia 

HTB Pinned

> https://www.youtube.com/watch?v=ENyEcwLaz-A

AndroidMobilePenstest

> https://github.com/tsug0d/AndroidMobilePentest101?tab=readme-ov-file




